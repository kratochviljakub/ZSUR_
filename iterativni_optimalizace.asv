% Rozdìlení dat metodou k-means do urèeného poètu tøíd
function [ ] = iterativni_optimalizace( tridy, stredy, zkresleni )
% tridy = rozdìlení bodù do shlukù
% stredy = støedy shlukù
% zkresleni = kriteriální funkce J

data_size = size(tridy);
[pocet_shluku,~] = size(stredy); % poèet shlukù
velikost_shluku = zeros(1, pocet_shluku); % poèet bodù v jednotlivých shlucích

% zjištìní poètu bodù ve shlucích
for i = 1:data_size(1)
    velikost_shluku(tridy(i,3)) = velikost_shluku(tridy(i,3)) + 1;
end


while true
   
   for i = 1:data_size(1)
       a = tridy(i,3) % do kolikátého shluku patøí bod x
      if  velikost_shluku(a) == 1
          break
      else
          % vzdálenosti mi a bodu x
          matice = zeros(1,pocet_shluku);
         
          for j = 1:pocet_shluku
              matice(j) = sum(((stredy(j,1) - tridy(i,1))^2 + (stredy(j,2) - tridy(i,2))^2));
          end
          
          % výpoèet A_i, A_j
          A = zeros(1,pocet_shluku);
          for j = 1:pocet_shluku
              if a == j
                  A(a) = (velikost_shluku(a) / (velikost_shluku(a) - 1)) * matice(a);
              else
                  A(j) = (velikost_shluku(j) / (velikost_shluku(j) + 1)) * matice(j);
              end
          end
          
          % pøesun prvku?
          tmp = A(a);
          A(A == A(a)) = 2*max(A); % "odstranìní" prvku A_i z pole
          [~,I] = min(A);
          if tmp > A(I)
              tridy(i,3) = I;
              zkresleni(I) =  zkresleni(I) + ((velikost_shluku(I)/(velikost_shluku(I) + 1)) * matice(I));
              zkresleni(a) =  zkresleni(a) - ((velikost_shluku(a)/(velikost_shluku(a) - 1)) * matice(a));
              stredy(I,1) = (tridy(a,1) - stredy(I,1)) / (velikost_shluku(I) + 1);
              stredy(I,2) = (tridy(a,2) - stredy(I,2)) / (velikost_shluku(I) + 1);
              stredy(a,1) = (tridy(a,1) - stredy(I,1)) / (velikost_shluku(I) + 1);
          
      end
   end
   if zkresleni_new == zkresleni % ukonèovací podmínka pøi nezmìnìném zkreslení
       break
   end
end







% náhodná volba poèáteèních støedù
mi = zeros(R,2);
tmp = zeros(R,1);
while true
    for i = 1:R
        r = 1 + (data_size(1)-1)*rand(1); % náhodné èíslo poèáteèního bodu
        r = round(r);
        tmp(i) = r;
    end
    if size(unique(tmp),1) == R
        break;
    end
end
%tmp = [1 2 3 4];
for i = 1:R
    mi(i,:) = data(tmp(i),:);
end
   

% algoritmus
while true
    % vzdálenosti mi a ostatních bodù
    matice = zeros(R,data_size(1));
    for i = 1:size(mi,1)
        for j = 1:data_size(1)
            matice(i,j) = sum((mi(i,:) - data(j,:)).^2);
        end
    end
    
    % rozdìlení dat do tøíd
    for i = 1:data_size(1)
        [~,I] = min(matice(:,i));
        tridy(i,3) = I;
    end
    
    % pøepoètení støedù shlukù
    mi_new = mi;
    for i = 1:R
        suma = zeros(1,data_size(2));
        counter = 0;
        for j = 1:data_size(1)
            if tridy(j,3) == i
                for k = 1:data_size(2)
                    suma(k) = suma(k) + tridy(j,k);
                end
                counter = counter + 1;
            end
        end
        suma = suma / counter;
        mi_new(i,:) = suma;
    end
    
    if mi_new == mi % kontrola ukonèovací podmínky
        break;
    else
        mi = mi_new;
        if c > 5000
            disp('Nìco se pokazilo v k-means');
            break;
        end
    end
    c = c + 1; %zastavovaci counter
end


%% test data
% data = [0 1; 2 1; 1 3; 1 -1; 1 5; 1 9; -1 7; 3 7];

%% vykreslení
figure
colors = [0 0 1; 0 0.5 0; 1 0 0; 0.75 0 0.75; 0 0.75 0.75; 0.75 0.75 0; 0 0 0];
% vykreslení bodù
for i = 1:data_size(1)   
    scatter(tridy(i,1), tridy(i,2),[], colors(tridy(i,3),:),'x')
    hold on
end

% vykreslení støedù
for i = 1:size(mi)
    scatter(mi(i,1), mi(i,2),[], colors(7,:),'filled')
end

title('Metoda k-means - rozdìlení dat do shlukù')
end

